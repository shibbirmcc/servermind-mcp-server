You are preparing ticket-ready items for an incident.

INPUT
- analysis: JSON from the narrative step. Contains per_trace[] with:
  - id (trace id), story (cross-service bullets), services[] (per-service analysis), per_service_repro_specs[] (optional)
- root_cause: JSON from the root-cause step. Contains:
  - main_tickets[] (optional): { trace_id, story, services_involved, window?, impact_hint? }
  - root_causes_per_service[]: each with service, trace_ids[], hypotheses[], recommended_fixes[], telemetry_gaps[]
- title_prefix: optional string to prepend to generated titles (may be empty)
- mode: "auto" | "strict"
  - strict: create sub tickets only for services with ≥1 hypothesis at/above confidence_floor (if provided in root_cause; else use 0.6)
  - auto: create sub tickets for services that show clear failure signals or any hypothesis (filter out extremely weak ones)

GOAL
Return a STRICT JSON ARRAY (top-level) of ticket items:
- Exactly one **main** ticket per trace:
  - Must include the original cross-service **story** and the **trace_id**.
- One **sub** ticket per **service** that shows errors or has hypotheses in root_cause:
  - Must include service-scoped **analysis** and the **root_cause** block (hypotheses + recommendations).

STRICT RULES
- Output **must be a JSON ARRAY**; do not wrap in an object and do not include any extra prose.
- Each item must have "type": "main" or "sub".
- **Main** items MUST have:
  - "type": "main"
  - "trace_id": "<string>"
  - "story": ["<bullet1>", "<bullet2>", ...]  // copy from analysis.per_trace[*].story
  - Optional: "title", "services_involved", "window", "impact_hint"
- **Sub** items MUST have:
  - "type": "sub"
  - "service": "<service_name>"
  - "trace_ids": ["<trace_id1>", ...]         // from root_cause for this service; if missing, collect from analysis
  - "analysis": {
      "timeline": [ { "t": "<ISO8601|raw>", "level":"<level>", "msg":"<short msg>" }, ... ],
      "inputs": { ... },                       // keep concise; omit if unknown
      "environment": { ... }                   // optional; omit if unknown
    }
  - "root_cause": {
      "hypotheses": [ ... up to 3 ... ],
      "recommended_fixes": [ ... ],
      "telemetry_gaps": [ ... ]
    }
  - Optional: "title", "owner_hint", "labels": ["incident", "<service>"]
- Omit empty arrays/objects.
- If data is unknown, omit the field rather than inventing values.
- Titles (if you include them) may be prefixed with title_prefix; keep titles concise.

MAPPING LOGIC

1) MAIN tickets (one per trace)
- For each analysis.per_trace[*]:
  - Create a "main" item.
  - trace_id = per_trace.id
  - story = per_trace.story  (copy)
  - services_involved = unique names from per_trace.services[*].service (if available)
  - window.first_seen/last_seen: infer from per-service timelines if timestamps are present; else omit
  - If title_prefix provided, title = f"{title_prefix} Incident – {trace_id}" (optional)

2) SUB tickets (service-scoped)
- Build a service index from:
  - root_cause.root_causes_per_service[*]  (primary truth for hypotheses & fixes)
  - analysis.per_trace[*].services[*]      (for per-service timelines/inputs/env)
- For each service S that appears in root_cause or has clear ERROR/FATAL signals in analysis:
  - Create a "sub" item:
    - service = S
    - trace_ids = from root_cause for S if present; else collect per_trace.id where S appears
    - analysis.timeline = the per-service timeline for S, kept concise (cap 10 most relevant rows)
    - analysis.inputs/environment = copy from analysis if available; omit otherwise
    - root_cause.hypotheses = from root_cause for S (up to 3; preserve confidence and any 'tentative' flag)
    - root_cause.recommended_fixes, root_cause.telemetry_gaps = copy from root_cause for S if present
  - MODE filter:
    - strict: include S only if it has ≥1 hypothesis with confidence ≥ confidence_floor (if field exists; else assume 0.6)
    - auto: include S if it has any hypothesis or clear error signals
  - Optional fields:
    - title = f"{title_prefix}{S}: investigate failure (linked to {len(trace_ids)} trace(s))"
    - owner_hint = S or inferred team name if available
    - labels = ["incident", S]

QUALITY GUARDRAILS
- Keep items minimal but actionable.
- Do not duplicate services; a service should appear in at most one "sub" item.
- Keep text compact (no walls of log output).
- Preserve exact codes/phrases where they strengthen clarity (e.g., SQLSTATE codes).
- Omit sections that would be empty.

OUTPUT
- Return ONLY the JSON ARRAY of ticket items. No extra text before or after.
