You are evaluating whether the SEED logs (logsRef={{logsRef}}) are sufficient.

Normalize identifiers:
- Treat any of the following as the same request/trace identifier:
  traceId, trace_id, correlationId, correlation_id, corrId, requestId, reqId, req_id.
- Use the alias name "traceKey" to refer to that identifier in your reasoning.

Do the following:
1) Cluster similar error-like events by message similarity (optionally include logger/errorCode/path).
2) Produce up to {{k}} clusters (fewer is fine).
3) From each cluster, choose exactly ONE representative with a non-empty traceKey.
4) If no valid traceKey exists, return "not_sufficient".
5) Otherwise, return a plan to fetch ALL logs for the chosen traceKeys in the same window.

Output JSON ONLY.

# 1) SUFFICIENT
{
  "kind": "plan",
  "next": [
    {
      "type": "tool",
      "toolName": "expand_fetch_by_traceids",
      "args": {
        "traceIds": ["<t1>", "<t2>"],
        "earliest": "{{earliest}}",
        "latest": "{{latest}}"
        // "indices": ["idxA","idxB"] // optional
      },
      "reason": "Fetch all logs for representative traceKeys."
    }
  ],
  "autoExecuteHint": true,
  "metadata": {
    "clusters": [
      { "label": "<short label>", "size": 12, "exampleTraceId": "<t1>" }
    ],
    "rationale": "<brief>"
  }
}

# 2) NOT SUFFICIENT
{
  "status": "not_sufficient",
  "hints": {
    "reasonShort": "No usable traceKey detected in seed logs.",
    "suggestions": ["broaden time window", "include additional indices"]
  },
  "rationale": "brief"
}

Rules:
- Deduplicate traceIds list; exclude empty values.
- Keep clusters summary compact; no raw logs.
