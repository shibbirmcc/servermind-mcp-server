You are finding Splunk index definitions for environment: {{env}}.
Attempt: {{attempt}}

The user may be in:
1) The codebase root.
2) A parent folder containing multiple codebases or services.

Your tasks:
1) Search the repo(s) for environment-to-index mappings.
2) Collect ALL candidate indices with metadata:
   - index: string (required)
   - env: string or null (if the source ties it to an env)
   - servicePath: string or null (folder where it was found, relative path preferred)
   - sourceFile: string (file path where it was found)
3) If many candidates span multiple envs or services, do NOT choose one here—just return them all.
4) If nothing is found, return status "not_found" with diagnostics of what you tried.

Search locations (check all that apply):
- config/splunk/index.map.json
- Helm charts (values.yaml, Chart.yaml)
- Kubernetes manifests (*.yaml, *.yml)
- application.yml / application.properties
- .env files (including .env*, e.g., .env.local, .env.production)
- Terraform (*.tf) / Ansible (*.yml) configs
- Logback / log4j configs (*.xml)
- Any file with SPLUNK_INDEX, splunk.index, or index=<value>

Suggested search commands:
ripgrep -n --no-ignore -e "SPLUNK_INDEX|splunk\\.index|hec.*index|index\\s*=" .
ripgrep -n --glob "!node_modules" -e "index:\\s*[a-zA-Z0-9_-]+" charts k8s config
ripgrep -n -e "splunk" -e "hec" config/ charts/ k8s/ terraform/ ansible/ src/
# If this is a retry (attempt > 0), broaden the search roots and file types:
ripgrep -n --hidden -e "SPLUNK_INDEX|splunk\\.index|index\\s*=" . services apps infra deploy
ripgrep -n -e "indexName|index_name|INDEX_NAME" .
ripgrep -n -e "values:.*index" -e "index:.*" .

How to interpret matches:
- If a file maps specific envs to indices (e.g., {"prod":"prod_app","staging":"staging_app"}), emit one candidate per mapping.
- If a file sets a single index (e.g., SPLUNK_INDEX=playground_app), emit that with env=null unless the path or file name clearly implies an env (e.g., values-staging.yaml → env="staging").
- servicePath should reflect the nearest service/module directory when inside a monorepo.

Output format:
Return JSON ONLY, no explanations. Use one of the following shapes:

# 1) FOUND (one or more candidates)
{
  "kind": "plan",
  "next": [
    {
      "type": "tool",
      "toolName": "get_resolve_splunk_index",
      "args": {
        "env": "{{env}}",
        "status": "found",
        "foundIndices": [
          {
            "index": "<string>",
            "env": "<string or null>",
            "servicePath": "<string or null>",
            "sourceFile": "<string>"
          }
        ],
        "attempt": {{attempt}}
      },
      "reason": "Discovered <N> index candidate(s) for env '{{env}}'."
    }
  ],
  "autoExecuteHint": true
}

# 2) AMBIGUOUS (too many candidates or mixed envs; still return them all)
{
  "kind": "plan",
  "next": [
    {
      "type": "tool",
      "toolName": "get_resolve_splunk_index",
      "args": {
        "env": "{{env}}",
        "status": "ambiguous",
        "foundIndices": [
          { "index": "...", "env": "...", "servicePath": "...", "sourceFile": "..." }
        ],
        "attempt": {{attempt}}
      },
      "reason": "Multiple plausible indices across services/envs for '{{env}}'."
    }
  ],
  "autoExecuteHint": true
}

# 3) NOT FOUND (nothing matched)
{
  "kind": "plan",
  "next": [
    {
      "type": "tool",
      "toolName": "get_resolve_splunk_index",
      "args": {
        "env": "{{env}}",
        "status": "not_found",
        "diagnostics": [
          "Searched: config/, charts/, k8s/, terraform/, ansible/, src/, .env*",
          "Patterns: SPLUNK_INDEX, splunk.index, hec.*index, index=, index:",
          "No matches found"
        ],
        "attempt": {{attempt}}
      },
      "reason": "No index found for env '{{env}}'."
    }
  ],
  "autoExecuteHint": true
}

Rules:
- Always return JSON in one of the three shapes above; do not include any extra text.
- When FOUND or AMBIGUOUS, include all candidates in foundIndices[] (objects with index/env/servicePath/sourceFile).
- env in each candidate may be null if the source does not specify it.
- Use relative paths where possible for servicePath/sourceFile.
- Keep reason concise.
